[
  {
    "id": "ex7",
    "name": "Linkedlist saving way to permutation",
    "description": [],
    "linksToLeetcodeQues": [
      {
        "title": "Iterator for Combination",
        "link": "https://leetcode.com/problems/iterator-for-combination/"
      }
    ],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "imgs/ll1.png",
    "complexity": "O(2^N)"
  },
  {
    "id": "ex6",
    "name": "Getting indexwise permutations using backtrack and bit manipulation",
    "description": [],
    "linksToLeetcodeQues": [
      {
        "title": "Combinations",
        "link": "https://leetcode.com/problems/combinations/"
      }
    ],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/bm1.png", "imgs/bm2.png"],
    "mainImg": "",
    "complexity": "O(2^N)"
  },
  {
    "id": "ex5",
    "name": "Bluebird",
    "description": [
      {
        "info": "Promisify: Returns a new function that returns a new promise instead of using callback",
        "link": "",
        "img": ["imgs/bb2.png"]
      },
      {
        "info": "Used on an error-first callback function",
        "link": "",
        "img": []
      },
      {
        "info": "PromisifyAll: It's a way of promisifying all async functions present in library instead of manually promisifying each of them",
        "link": "",
        "img": ["imgs/bb3.png"]
      },
      {
        "info": "Promise.bind: This is similar to function.prototype.bind, only that it creates a promise function that binds to this",
        "link": "",
        "img": ["imgs/bb4.png"]
      },
      {
        "info": "Promise.All: Let's us provide an array of promise, then using spread function, we will get their resolution in the sequence of promise in array. spread function generally flattens the array but suppose if we dont want to use this then result is going to be an array",
        "link": "",
        "img": ["imgs/bb5.png"]
      },
      {
        "info": "Promis.join: Very similar to Promise.all, if you have a set number of promises and you want to pass then directly as parameter and not push in array, then u will get result respecitively. I am much better performant than promise.all.",
        "link": "",
        "img": ["imgs/bb6.png"]
      },
      {
        "info": "Promise.map: Allows you to work on array with less biolerplatecode.",
        "link": "",
        "img": ["imgs/bb7.png"]
      },
      {
        "info": "Promise.map: It also has one more advantage of controlling array length to be given. Let's say api server allows only 10 items in one go then using concruency we can take care of it. When those 10 are resolved then next 10 will be sent",
        "link": "",
        "img": ["imgs/bb8.png"]
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [
      {
        "title": "Youtube link to Bluebird tutorial",
        "href": "https://www.youtube.com/watch?v=hQxFymzhT3A"
      }
    ],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex4",
    "name": "Typescript Handbook",
    "description": [
      {
        "info": "The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).",
        "link": [],
        "img": []
      },
      {
        "info": "Use interface to define javascript object, and those objects that are defined are only going to be used, if you want to add more property after creating interface, you can do it directly, it will throw error",
        "link": [
          {
            "title": "Javascript to Typescript",
            "href": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"
          }
        ],
        "img": []
      },
      {
        "info": "Unions (|) provide a way to handle different types too.",
        "link": [],
        "img": ["imgs/tsunion.png"]
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex3",
    "name": "Trie, basic population and little backtracking",
    "description": [
      {
        "info": "It's a huge dictionary which accomodate entire word or sentence. Literally best way to find any commonly starting word",
        "link": [],
        "img": []
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "imgs/trie.png",
    "complexity": "Not much info"
  },
  {
    "id": "ex1",
    "name": "Bit Manipulation - Basics usecases of AND, OR, XOR",
    "description": [
      {
        "info": "It's more than amazing if you know what you are doing, working on bit instead of decimals is of direct use and it's super fast.",
        "link": [],
        "img": []
      },
      {
        "info": "For few things like find even/odd, divide/multiply by 2, everything is amazingly useful",
        "link": [],
        "img": []
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "imgs/bm.png",
    "complexity": "Not much info"
  },
  {
    "id": "ex2",
    "name": "String/Array Includes",
    "description": [
      {
        "info": "Saving information in string is easy, it's 'string'.includes('search something') is O(0), no matter how many times you do, even in loop it's staight zero after running through all. Very helpful. However same is not true for [].includes(''), it's o(N) where N is the length of array",
        "link": [],
        "img": []
      }
    ],
    "proof": "\nfunction test(n){\nn = n.split(''); \nconst a = performance.now(); \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0'); \nconst b = performance.now(); \nreturn b-a;} \nTime complexity for using it as 3.2000000178813934  \nTime complexity for using just for string includes is 0 which is constant which means below function is: \nfunction test(n){\n const a = performance.now();\n n.includes('0');\n   n.includes('0');\nn.includes('0');\n    n.includes('0');\n    n.includes('0');\n    n.includes('0');\n    const b = performance.now();\n    return b-a;}\nResult is constant",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/arry.png", "imgs/str.png"],
    "mainImg": "",
    "complexity": "O(1) for includes in string and O(N) for includes in array"
  }
]
