[
  {
    "id": "ex11",
    "name": "Messaging protocols",
    "description": [
      {
        "info": "UDP: User datagram protocol: It is fire and forget protocol as there is no gurantee if data will be reached completely or not or even in same order, which is why it is way faster than UDP",
        "link": [],
        "img": []
      },
      {
        "info": "TCP - Transfer Control Protocol: It happens only after a connection called handshake",
        "link": [],
        "img": []
      }
    ],
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [
      {
        "title": "Video link to undestand difference between TCP and UDP",
        "href": "https://www.youtube.com/watch?v=uwoD5YsGACg"
      }
    ],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex10",
    "name": "Seach Engine Optimization",
    "description": [
      {
        "info": "if SEO is your priority, typically when you are building a blog site and you want everyone who searching on google go to your website, then SSR is your choice.",
        "link": [
          {
            "title": "Difference between SSR and CSR",
            "href": "https://dev.to/alain2020/ssr-vs-csr-2617"
          }
        ],
        "img": []
      },
      {
        "info": "The Largest Contentful Paint (LCP) metric looks at the perceived loading speed of your page. LCP measures the time it takes to get the largest element on the page visible within the viewport. This could be a large text block, video, or image that takes up the primary real estate on the page.",
        "link": [
          {
            "title": "The Largest Contentful Paint (LCP)",
            "href": "https://vercel.com/blog/core-web-vitals#largest-contentful-paint"
          }
        ],
        "img": []
      },
      {
        "info": "The First Contentful Paint (FCP) metric measures the time from when the page starts loading to when any part of the page's content is rendered on the screen. For this metric, `content` refers to text, images (including background images), <svg> elements, or non-white <canvas> elements.",
        "link": [
          {
            "title": "The First Contentful Paint (FCP)",
            "href": "https://web.dev/fcp/"
          }
        ],
        "img": ["imgs/seo1.png"]
      }
    ],
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex9",
    "name": "NextJs",
    "description": [
      {
        "info": "By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.\n\nEach generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called hydration.)",
        "link": [
          {
            "title": "Pre-Rendering",
            "href": "https://nextjs.org/docs/basic-features/pages#pre-rendering"
          }
        ],
        "img": []
      },
      {
        "info": "Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.\n\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request.\nServer-side Rendering: The HTML is generated on each request.\n\nImportantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a 'hybrid' Next.js app by using Static Generation for most pages and using Server-side Rendering for others.",
        "link": [
          {
            "title": "Two forms of pre rendering",
            "href": "https://nextjs.org/docs/basic-features/pages#two-forms-of-pre-rendering"
          }
        ],
        "img": []
      },
      {
        "info": "The name “SWR” is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by HTTP RFC 5861. SWR is a strategy to first return the data from cache (stale), then send the fetch request (revalidate), and finally come with the up-to-date data.\n\nWith SWR, components will get a stream of data updates constantly and automatically.\nAnd the UI will be always fast and reactive.",
        "link": [{ "title": "SWR: main", "href": "https://swr.vercel.app/" }],
        "img": []
      },
      {
        "info": "SWR(stale-while-revalidate): The team behind Next.js has created a React hook for data fetching called SWR. We highly recommend it if you’re fetching data on the client side. It handles caching, revalidation, focus tracking, refetching on interval, and more. And you can use it like so:",
        "link": [
          {
            "title": "SWR",
            "href": "https://nextjs.org/docs/basic-features/data-fetching#swr"
          }
        ],
        "img": ["imgs/nx1.png"]
      },
      {
        "info": "Recommended using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.\nYou can use Static Generation for many types of pages, including: \n\nMarketing pages\nBlog posts and portfolios\nE-commerce product listings\nHelp and documentation",
        "link": [
          {
            "title": "When to use static generation",
            "href": "https://nextjs.org/docs/basic-features/pages#when-should-i-use-static-generation"
          }
        ],
        "img": []
      },
      {
        "info": "Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use these functions that Next.js provides:\n\nYour page content depends on external data: Use getStaticProps.\nYour page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps).",
        "link": [
          {
            "title": "",
            "href": "https://nextjs.org/docs/basic-features/pages#static-generation-with-data"
          }
        ],
        "img": []
      }
    ],
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex8",
    "name": "Breadth for search",
    "description": [],
    "linksToLeetcodeQues": [
      {
        "title": "Maximum Depth of N-ary Tree",
        "href": "https://leetcode.com/problems/maximum-depth-of-n-ary-tree/"
      },
      {
        "title": "Maximum Depth of Binary Tree",
        "href": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
      }
    ],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/bfs1.png", "imgs/bfs2.png"],
    "mainImg": "",
    "complexity": "O(2^N)"
  },
  {
    "id": "ex7",
    "name": "Linkedlist saving way to permutation",
    "description": [],
    "linksToLeetcodeQues": [
      {
        "title": "Iterator for Combination",
        "href": "https://leetcode.com/problems/iterator-for-combination/"
      }
    ],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/ll1.png"],
    "mainImg": "",
    "complexity": "O(2^N)"
  },
  {
    "id": "ex6",
    "name": "Getting indexwise permutations using backtrack and bit manipulation",
    "description": [],
    "linksToLeetcodeQues": [
      {
        "title": "Combinations",
        "href": "https://leetcode.com/problems/combinations/"
      }
    ],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/bm1.png", "imgs/bm2.png"],
    "mainImg": "",
    "complexity": "O(2^N)"
  },
  {
    "id": "ex5",
    "name": "Bluebird",
    "description": [
      {
        "info": "Promisify: Returns a new function that returns a new promise instead of using callback",
        "link": [],
        "img": ["imgs/bb2.png"]
      },
      {
        "info": "Used on an error-first callback function",
        "link": [],
        "img": []
      },
      {
        "info": "PromisifyAll: It's a way of promisifying all async functions present in library instead of manually promisifying each of them",
        "link": [],
        "img": ["imgs/bb3.png"]
      },
      {
        "info": "Promise.bind: This is similar to function.prototype.bind, only that it creates a promise function that binds to this",
        "link": [],
        "img": ["imgs/bb4.png"]
      },
      {
        "info": "Promise.All: Let's us provide an array of promise, then using spread function, we will get their resolution in the sequence of promise in array. spread function generally flattens the array but suppose if we dont want to use this then result is going to be an array",
        "link": [],
        "img": ["imgs/bb5.png"]
      },
      {
        "info": "Promis.join: Very similar to Promise.all, if you have a set number of promises and you want to pass then directly as parameter and not push in array, then u will get result respecitively. I am much better performant than promise.all.",
        "link": [],
        "img": ["imgs/bb6.png"]
      },
      {
        "info": "Promise.map: Allows you to work on array with less biolerplatecode.",
        "link": [],
        "img": ["imgs/bb7.png"]
      },
      {
        "info": "Promise.map: It also has one more advantage of controlling array length to be given. Let's say api server allows only 10 items in one go then using concruency we can take care of it. When those 10 are resolved then next 10 will be sent",
        "link": [],
        "img": ["imgs/bb8.png"]
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [
      {
        "title": "Youtube link to Bluebird tutorial",
        "href": "https://www.youtube.com/watch?v=hQxFymzhT3A"
      }
    ],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex4",
    "name": "Typescript Handbook",
    "description": [
      {
        "info": "The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).",
        "link": [],
        "img": []
      },
      {
        "info": "Use interface to define javascript object, and those objects that are defined are only going to be used, if you want to add more property after creating interface, you can do it directly, it will throw error",
        "link": [
          {
            "title": "Javascript to Typescript",
            "href": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"
          }
        ],
        "img": []
      },
      {
        "info": "Unions (|) provide a way to handle different types too.",
        "link": [],
        "img": ["imgs/tsunion.png"]
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex3",
    "name": "Trie, basic population and little backtracking",
    "description": [
      {
        "info": "It's a huge dictionary which accomodate entire word or sentence. Literally best way to find any commonly starting word",
        "link": [],
        "img": []
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "imgs/trie.png",
    "complexity": "Not much info"
  },
  {
    "id": "ex1",
    "name": "Bit Manipulation - Basics usecases of AND, OR, XOR",
    "description": [
      {
        "info": "It's more than amazing if you know what you are doing, working on bit instead of decimals is of direct use and it's super fast.",
        "link": [],
        "img": []
      },
      {
        "info": "For few things like find even/odd, divide/multiply by 2, everything is amazingly useful",
        "link": [],
        "img": []
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "imgs/bm.png",
    "complexity": "Not much info"
  },
  {
    "id": "ex2",
    "name": "String/Array Includes",
    "description": [
      {
        "info": "Saving information in string is easy, it's 'string'.includes('search something') is O(0), no matter how many times you do, even in loop it's staight zero after running through all. Very helpful. However same is not true for [].includes(''), it's o(N) where N is the length of array",
        "link": [],
        "img": []
      }
    ],
    "proof": "\nfunction test(n){\nn = n.split(''); \nconst a = performance.now(); \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0'); \nconst b = performance.now(); \nreturn b-a;} \nTime complexity for using it as 3.2000000178813934  \nTime complexity for using just for string includes is 0 which is constant which means below function is: \nfunction test(n){\n const a = performance.now();\n n.includes('0');\n   n.includes('0');\nn.includes('0');\n    n.includes('0');\n    n.includes('0');\n    n.includes('0');\n    const b = performance.now();\n    return b-a;}\nResult is constant",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/arry.png", "imgs/str.png"],
    "mainImg": "",
    "complexity": "O(1) for includes in string and O(N) for includes in array"
  }
]
