[
  {
    "id": "ex9",
    "name": "NextJs",
    "description": [
      {
        "info": "By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.\n\nEach generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called hydration.)",
        "link": [
          {
            "title": "Pre-Rendering",
            "href": "https://nextjs.org/docs/basic-features/pages#pre-rendering"
          }
        ],
        "img": []
      },
      {
        "info": "Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.\n\nStatic Generation (Recommended): The HTML is generated at build time and will be reused on each request.\nServer-side Rendering: The HTML is generated on each request.\n\nImportantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a 'hybrid' Next.js app by using Static Generation for most pages and using Server-side Rendering for others.",
        "link": [
          {
            "title": "Two forms of pre rendering",
            "href": "https://nextjs.org/docs/basic-features/pages#two-forms-of-pre-rendering"
          }
        ],
        "img": []
      },
      {
        "info": "The name “SWR” is derived from stale-while-revalidate, a HTTP cache invalidation strategy popularized by HTTP RFC 5861. SWR is a strategy to first return the data from cache (stale), then send the fetch request (revalidate), and finally come with the up-to-date data.\n\nWith SWR, components will get a stream of data updates constantly and automatically.\nAnd the UI will be always fast and reactive.",
        "link": [{ "title": "SWR: main", "href": "https://swr.vercel.app/" }],
        "img": []
      },
      {
        "info": "SWR(stale-while-revalidate): The team behind Next.js has created a React hook for data fetching called SWR. We highly recommend it if you’re fetching data on the client side. It handles caching, revalidation, focus tracking, refetching on interval, and more. And you can use it like so:",
        "link": [
          {
            "title": "SWR",
            "href": "https://nextjs.org/docs/basic-features/data-fetching#swr"
          }
        ],
        "img": ["imgs/nx1.png"]
      }
    ],
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex8",
    "name": "Breadth for search",
    "description": [],
    "linksToLeetcodeQues": [
      {
        "title": "Maximum Depth of N-ary Tree",
        "href": "https://leetcode.com/problems/maximum-depth-of-n-ary-tree/"
      },
      {
        "title": "Maximum Depth of Binary Tree",
        "href": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
      }
    ],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/bfs1.png", "imgs/bfs2.png"],
    "mainImg": "",
    "complexity": "O(2^N)"
  },
  {
    "id": "ex7",
    "name": "Linkedlist saving way to permutation",
    "description": [],
    "linksToLeetcodeQues": [
      {
        "title": "Iterator for Combination",
        "href": "https://leetcode.com/problems/iterator-for-combination/"
      }
    ],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/ll1.png"],
    "mainImg": "",
    "complexity": "O(2^N)"
  },
  {
    "id": "ex6",
    "name": "Getting indexwise permutations using backtrack and bit manipulation",
    "description": [],
    "linksToLeetcodeQues": [
      {
        "title": "Combinations",
        "href": "https://leetcode.com/problems/combinations/"
      }
    ],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/bm1.png", "imgs/bm2.png"],
    "mainImg": "",
    "complexity": "O(2^N)"
  },
  {
    "id": "ex5",
    "name": "Bluebird",
    "description": [
      {
        "info": "Promisify: Returns a new function that returns a new promise instead of using callback",
        "link": [],
        "img": ["imgs/bb2.png"]
      },
      {
        "info": "Used on an error-first callback function",
        "link": [],
        "img": []
      },
      {
        "info": "PromisifyAll: It's a way of promisifying all async functions present in library instead of manually promisifying each of them",
        "link": [],
        "img": ["imgs/bb3.png"]
      },
      {
        "info": "Promise.bind: This is similar to function.prototype.bind, only that it creates a promise function that binds to this",
        "link": [],
        "img": ["imgs/bb4.png"]
      },
      {
        "info": "Promise.All: Let's us provide an array of promise, then using spread function, we will get their resolution in the sequence of promise in array. spread function generally flattens the array but suppose if we dont want to use this then result is going to be an array",
        "link": [],
        "img": ["imgs/bb5.png"]
      },
      {
        "info": "Promis.join: Very similar to Promise.all, if you have a set number of promises and you want to pass then directly as parameter and not push in array, then u will get result respecitively. I am much better performant than promise.all.",
        "link": [],
        "img": ["imgs/bb6.png"]
      },
      {
        "info": "Promise.map: Allows you to work on array with less biolerplatecode.",
        "link": [],
        "img": ["imgs/bb7.png"]
      },
      {
        "info": "Promise.map: It also has one more advantage of controlling array length to be given. Let's say api server allows only 10 items in one go then using concruency we can take care of it. When those 10 are resolved then next 10 will be sent",
        "link": [],
        "img": ["imgs/bb8.png"]
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [
      {
        "title": "Youtube link to Bluebird tutorial",
        "href": "https://www.youtube.com/watch?v=hQxFymzhT3A"
      }
    ],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex4",
    "name": "Typescript Handbook",
    "description": [
      {
        "info": "The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).",
        "link": [],
        "img": []
      },
      {
        "info": "Use interface to define javascript object, and those objects that are defined are only going to be used, if you want to add more property after creating interface, you can do it directly, it will throw error",
        "link": [
          {
            "title": "Javascript to Typescript",
            "href": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"
          }
        ],
        "img": []
      },
      {
        "info": "Unions (|) provide a way to handle different types too.",
        "link": [],
        "img": ["imgs/tsunion.png"]
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "",
    "complexity": "Ignore"
  },
  {
    "id": "ex3",
    "name": "Trie, basic population and little backtracking",
    "description": [
      {
        "info": "It's a huge dictionary which accomodate entire word or sentence. Literally best way to find any commonly starting word",
        "link": [],
        "img": []
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "imgs/trie.png",
    "complexity": "Not much info"
  },
  {
    "id": "ex1",
    "name": "Bit Manipulation - Basics usecases of AND, OR, XOR",
    "description": [
      {
        "info": "It's more than amazing if you know what you are doing, working on bit instead of decimals is of direct use and it's super fast.",
        "link": [],
        "img": []
      },
      {
        "info": "For few things like find even/odd, divide/multiply by 2, everything is amazingly useful",
        "link": [],
        "img": []
      }
    ],
    "proof": "",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": [],
    "mainImg": "imgs/bm.png",
    "complexity": "Not much info"
  },
  {
    "id": "ex2",
    "name": "String/Array Includes",
    "description": [
      {
        "info": "Saving information in string is easy, it's 'string'.includes('search something') is O(0), no matter how many times you do, even in loop it's staight zero after running through all. Very helpful. However same is not true for [].includes(''), it's o(N) where N is the length of array",
        "link": [],
        "img": []
      }
    ],
    "proof": "\nfunction test(n){\nn = n.split(''); \nconst a = performance.now(); \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0');  \nn.includes('0'); \nconst b = performance.now(); \nreturn b-a;} \nTime complexity for using it as 3.2000000178813934  \nTime complexity for using just for string includes is 0 which is constant which means below function is: \nfunction test(n){\n const a = performance.now();\n n.includes('0');\n   n.includes('0');\nn.includes('0');\n    n.includes('0');\n    n.includes('0');\n    n.includes('0');\n    const b = performance.now();\n    return b-a;}\nResult is constant",
    "linksToLeetcodeQues": [],
    "linksToGoodArticleAndVideo": [],
    "imgs": ["imgs/arry.png", "imgs/str.png"],
    "mainImg": "",
    "complexity": "O(1) for includes in string and O(N) for includes in array"
  }
]
